<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fantasy&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://majiaji.github.io/"/>
  <updated>2016-12-11T17:25:02.000Z</updated>
  <id>https://majiaji.github.io/</id>
  
  <author>
    <name>fantasy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Guava Cache</title>
    <link href="https://majiaji.github.io/2016/12/11/Guava-Cache/"/>
    <id>https://majiaji.github.io/2016/12/11/Guava-Cache/</id>
    <published>2016-12-11T05:31:42.000Z</published>
    <updated>2016-12-11T17:25:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava-Cache简介"><a href="#Guava-Cache简介" class="headerlink" title="Guava Cache简介"></a>Guava Cache简介</h2><p>Local Cache是比较常用的后端开发“组件”，Guava中的Cache是一个很实用的Local Cache的实现，它支持下列特性：</p>
<ul>
<li>automatic loading of entries into the cache</li>
<li>least-recently-used eviction when a maximum size is exceeded</li>
<li>time-based expiration of entries, measured since last access or last write</li>
<li>keys automatically wrapped in weak references</li>
<li>values automatically wrapped in weak or soft references</li>
<li>notification of evicted (or otherwise removed) entries</li>
<li>accumulation of cache access statistics</li>
</ul>
<p>这些特性都是可选的，可在初始化时的建造者模式中进行配置。<br>今天主要根据源码来讲一下Guava Cache（19.0）的实现，具体的应用方法可以参考<a href="https://github.com/google/guava/wiki/CachesExplained" target="_blank" rel="external">官方文档</a>。</p>
<a id="more"></a>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="“过期”策略介绍"><a href="#“过期”策略介绍" class="headerlink" title="“过期”策略介绍"></a>“过期”策略介绍</h3><p>在讲源码之前首先介绍两个常用的过期策略：expireAfterWrite和refreshAfterWrite。这两个策略都能保证在本地缓存过期时，只有一个线程去加载后端资源（远端缓存或者db)。不同的是，在加载资源时，expireAfterWrite会让所有的线程阻塞等待新值返回,然后返回加载好的新值；而refreshAfterWrite在一个线程去拿新值的同时，其他线程先直接返回旧值，不阻塞。</p>
<p>get方法主要实现了上述逻辑。</p>
<h3 id="get分析"><a href="#get分析" class="headerlink" title="get分析"></a>get分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// loading</span></div><div class="line"></div><div class="line">     <span class="function">V <span class="title">get</span><span class="params">(K key, <span class="keyword">int</span> hash, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</div><div class="line">      checkNotNull(key);</div><div class="line">      checkNotNull(loader);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//count是这个segment中“存活”的元素数量，第一次命中时为0</span></div><div class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123; <span class="comment">// read-volatile</span></div><div class="line">          <span class="comment">// don't call getLiveEntry, which would ignore loading values</span></div><div class="line">          ReferenceEntry&lt;K, V&gt; e = getEntry(key, hash);</div><div class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">long</span> now = map.ticker.read();</div><div class="line">            <span class="comment">//获取有效的，且没有过期的值</span></div><div class="line">            V value = getLiveValue(e, now);</div><div class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">//CacheStats打点记录</span></div><div class="line">              recordRead(e, now);</div><div class="line">              statsCounter.recordHits(<span class="number">1</span>);</div><div class="line">              <span class="comment">//refresh的逻辑，不阻塞先返回旧值</span></div><div class="line">              <span class="keyword">return</span> scheduleRefresh(e, key, hash, value, now, loader);</div><div class="line">            &#125;</div><div class="line">            ValueReference&lt;K, V&gt; valueReference = e.getValueReference();</div><div class="line">            <span class="keyword">if</span> (valueReference.isLoading()) &#123;</div><div class="line">              <span class="comment">//已经有一个线程去load了，这里同步等待返回的新值</span></div><div class="line">              <span class="keyword">return</span> waitForLoadingValue(e, key, valueReference);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// at this point e is either null or expired;</span></div><div class="line">        <span class="comment">//拿锁并返回已经存在的值，或者进行同步的load</span></div><div class="line">        <span class="keyword">return</span> lockedGetOrLoad(key, hash, loader);</div><div class="line">      &#125; <span class="keyword">catch</span> (ExecutionException ee) &#123;</div><div class="line">        Throwable cause = ee.getCause();</div><div class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionError((Error) cause);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedExecutionException(cause);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> ee;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        postReadCleanup();</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>get中的scheduleRefresh:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">V <span class="title">scheduleRefresh</span><span class="params">(ReferenceEntry&lt;K, V&gt; entry, K key, <span class="keyword">int</span> hash, V oldValue, <span class="keyword">long</span> now,</span></span></div><div class="line">       CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader) &#123;</div><div class="line">     <span class="keyword">if</span> (map.refreshes() &amp;&amp; (now - entry.getWriteTime() &gt; map.refreshNanos)</div><div class="line">         &amp;&amp; !entry.getValueReference().isLoading()) &#123;</div><div class="line">         <span class="comment">//如果没有线程在loading，则去load新值</span></div><div class="line">       V newValue = refresh(key, hash, loader, <span class="keyword">true</span>);</div><div class="line">       <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">return</span> newValue;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//否则直接返回旧值</span></div><div class="line">     <span class="keyword">return</span> oldValue;</div><div class="line">   &#125;</div><div class="line"></div></pre></td></tr></table></figure><br>get中的lockedGetOrLoad:<br>一般第一次加载某个key对应的value，或者expireAfterWrite策略中value过期时会进入到这个函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">V <span class="title">lockedGetOrLoad</span><span class="params">(K key, <span class="keyword">int</span> hash, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader)</span></span></div><div class="line">        <span class="keyword">throws</span> ExecutionException &#123;</div><div class="line">      ReferenceEntry&lt;K, V&gt; e;</div><div class="line">      ValueReference&lt;K, V&gt; valueReference = <span class="keyword">null</span>;</div><div class="line">      LoadingValueReference&lt;K, V&gt; loadingValueReference = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">boolean</span> createNewEntry = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">      lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// re-read ticker once inside the lock</span></div><div class="line">        <span class="keyword">long</span> now = map.ticker.read();</div><div class="line">        preWriteCleanup(now);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> newCount = <span class="keyword">this</span>.count - <span class="number">1</span>;</div><div class="line">        AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = <span class="keyword">this</span>.table;</div><div class="line">        <span class="keyword">int</span> index = hash &amp; (table.length() - <span class="number">1</span>);</div><div class="line">        ReferenceEntry&lt;K, V&gt; first = table.get(index);</div><div class="line"></div><div class="line">        <span class="comment">//找到元素判断是否过期，返回或者执行清理</span></div><div class="line">        <span class="keyword">for</span> (e = first; e != <span class="keyword">null</span>; e = e.getNext()) &#123;</div><div class="line">          K entryKey = e.getKey();</div><div class="line">          <span class="keyword">if</span> (e.getHash() == hash &amp;&amp; entryKey != <span class="keyword">null</span></div><div class="line">              &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) &#123;</div><div class="line">            valueReference = e.getValueReference();</div><div class="line">            <span class="keyword">if</span> (valueReference.isLoading()) &#123;</div><div class="line">              createNewEntry = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              V value = valueReference.get();</div><div class="line">              <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">                enqueueNotification(entryKey, hash, valueReference, RemovalCause.COLLECTED);</div><div class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.isExpired(e, now)) &#123;</div><div class="line">                <span class="comment">// This is a duplicate check, as preWriteCleanup already purged expired</span></div><div class="line">                <span class="comment">// entries, but let's accomodate an incorrect expiration queue.</span></div><div class="line">                enqueueNotification(entryKey, hash, valueReference, RemovalCause.EXPIRED);</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                recordLockedRead(e, now);</div><div class="line">                statsCounter.recordHits(<span class="number">1</span>);</div><div class="line">                <span class="comment">// we were concurrent with loading; don't consider refresh</span></div><div class="line">                <span class="keyword">return</span> value;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// immediately reuse invalid entries</span></div><div class="line">              writeQueue.remove(e);</div><div class="line">              accessQueue.remove(e);</div><div class="line">              <span class="keyword">this</span>.count = newCount; <span class="comment">// write-volatile</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//新建的元素，先做一些初始化的动作</span></div><div class="line">        <span class="keyword">if</span> (createNewEntry) &#123;</div><div class="line">          loadingValueReference = <span class="keyword">new</span> LoadingValueReference&lt;K, V&gt;();</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">            e = newEntry(key, hash, first);</div><div class="line">            e.setValueReference(loadingValueReference);</div><div class="line">            table.set(index, e);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            e.setValueReference(loadingValueReference);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        unlock();</div><div class="line">        postWriteCleanup();</div><div class="line">      &#125;</div><div class="line"></div><div class="line"><span class="comment">//新建的元素，同步去远端load值</span></div><div class="line">      <span class="keyword">if</span> (createNewEntry) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">// Synchronizes on the entry to allow failing fast when a recursive load is</span></div><div class="line">          <span class="comment">// detected. This may be circumvented when an entry is copied, but will fail fast most</span></div><div class="line">          <span class="comment">// of the time.</span></div><div class="line">          <span class="keyword">synchronized</span> (e) &#123;</div><div class="line">            <span class="keyword">return</span> loadSync(key, hash, loadingValueReference, loader);</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          statsCounter.recordMisses(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// The entry already exists. Wait for loading.</span></div><div class="line">        <span class="comment">//否则阻塞等待别的线程load</span></div><div class="line">        <span class="keyword">return</span> waitForLoadingValue(e, key, valueReference);</div><div class="line">      &#125;</div><div class="line">    &#125; </div></pre></td></tr></table></figure></p>
<p>get中的waitForLoadingValue:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">waitForLoadingValue</span><span class="params">(ReferenceEntry&lt;K, V&gt; e, K key, ValueReference&lt;K, V&gt; valueReference)</span></span></div><div class="line">       <span class="keyword">throws</span> ExecutionException &#123;</div><div class="line">     <span class="keyword">if</span> (!valueReference.isLoading()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     checkState(!Thread.holdsLock(e), <span class="string">"Recursive load of: %s"</span>, key);</div><div class="line">     <span class="comment">// don't consider expiration as we're concurrent with loading</span></div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//getUninterruptibly同步获取</span></div><div class="line">       V value = valueReference.waitForValue();</div><div class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InvalidCacheLoadException(<span class="string">"CacheLoader returned null for key "</span> + key + <span class="string">"."</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// re-read ticker now that loading has completed</span></div><div class="line">       <span class="keyword">long</span> now = map.ticker.read();</div><div class="line">       recordRead(e, now);</div><div class="line">       <span class="keyword">return</span> value;</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       statsCounter.recordMisses(<span class="number">1</span>);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div></pre></td></tr></table></figure><br>这里需要注意，如果在guava cache中，去远端load回结果为null，这时不会返回null，而是直接抛异常InvalidCacheLoadException出来。在db操作中，load结果为null是很常见的，所以一定要注意处理这点。</p>
<p>目前的解决办法是，拿到db返回结果时先判断下是否为null，如果为null则返回一个空对象出去。外边函数拿到get的结果后先取这个对象的一个属性，比如一个DO的id，判断是否为null，如果为null则返回null，否则返回对象本身。</p>
<h2 id="思考和总结"><a href="#思考和总结" class="headerlink" title="思考和总结"></a>思考和总结</h2><p>从代码中可以看出，Guava Cache不管是哪种过期策略，都是触发式的：即每一次的过期和reload动作都依赖外部的请求。所谓的refresh并不是自己起了一个线程去不停的reload。在getLiveValue方法中判断过期元素也不包括refresh策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(ReferenceEntry&lt;K, V&gt; entry, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">   checkNotNull(entry);</div><div class="line">   <span class="keyword">if</span> (expiresAfterAccess()</div><div class="line">       &amp;&amp; (now - entry.getAccessTime() &gt;= expireAfterAccessNanos)) &#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (expiresAfterWrite()</div><div class="line">       &amp;&amp; (now - entry.getWriteTime() &gt;= expireAfterWriteNanos)) &#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>这样的话，如果用了refreshAfterWrite，在load完一个值之后，过了很久同时来了一拨并发请求，那么大量请求都会拿到旧的值，可能会导致业务上的问题。不过这种场景也是有点略奇葩，不太常见。所以在使用各个特性时一定要结合自己的业务，如果不确定最好先写个小的demo试一下。最后再提一下，expireAfterWrite和refreshAfterWrite是可以一起使用的，官方文档中也有说明:<br><blockquote><p>In contrast to expireAfterWrite, refreshAfterWrite will make a key eligible for refresh after the specified duration, but a refresh will only be actually initiated when the entry is queried. (If CacheLoader.reload is implemented to be asynchronous, then the query will not be slowed down by the refresh.) So, for example, you can specify both refreshAfterWrite and expireAfterWrite on the same cache, so that the expiration timer on an entry isn’t blindly reset whenever an entry becomes eligible for a refresh, so if an entry isn’t queried after it comes eligible for refreshing, it is allowed to expire.</p>
</blockquote></p>
<p>Guava Cache的设计是很好的，但是感觉实现上不够“优雅”，代码读起来有点难受，整个是一个猜测-&gt;验证-&gt;明白的学习过程。如果有问题欢迎讨论交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Guava-Cache简介&quot;&gt;&lt;a href=&quot;#Guava-Cache简介&quot; class=&quot;headerlink&quot; title=&quot;Guava Cache简介&quot;&gt;&lt;/a&gt;Guava Cache简介&lt;/h2&gt;&lt;p&gt;Local Cache是比较常用的后端开发“组件”，Guava中的Cache是一个很实用的Local Cache的实现，它支持下列特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;automatic loading of entries into the cache&lt;/li&gt;
&lt;li&gt;least-recently-used eviction when a maximum size is exceeded&lt;/li&gt;
&lt;li&gt;time-based expiration of entries, measured since last access or last write&lt;/li&gt;
&lt;li&gt;keys automatically wrapped in weak references&lt;/li&gt;
&lt;li&gt;values automatically wrapped in weak or soft references&lt;/li&gt;
&lt;li&gt;notification of evicted (or otherwise removed) entries&lt;/li&gt;
&lt;li&gt;accumulation of cache access statistics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些特性都是可选的，可在初始化时的建造者模式中进行配置。&lt;br&gt;今天主要根据源码来讲一下Guava Cache（19.0）的实现，具体的应用方法可以参考&lt;a href=&quot;https://github.com/google/guava/wiki/CachesExplained&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="后台" scheme="https://majiaji.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="Guava" scheme="https://majiaji.github.io/tags/Guava/"/>
    
      <category term="后台" scheme="https://majiaji.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Guava BloomFilter</title>
    <link href="https://majiaji.github.io/2016/12/04/Guava-BloomFilter/"/>
    <id>https://majiaji.github.io/2016/12/04/Guava-BloomFilter/</id>
    <published>2016-12-04T14:00:12.000Z</published>
    <updated>2016-12-04T17:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BloomFilter简介"><a href="#BloomFilter简介" class="headerlink" title="BloomFilter简介"></a>BloomFilter简介</h2><p>BloomFilter是一个可以快速判断一个元素是否在一个集合中的组件，它的设计也比较容易理解：构建的时候，一个元素经过几个hash函数hash后，命中一个bit数组的不同的位点，并把位点置为1。在判断的时候，也要执行同样的hash函数，只要有一个没有命中则这个元素一定不存在；否则有可能存在。只会有一种“误判”的情况：元素不在集合中，但被判断为在集合中。</p>
<p>因为构建时候多个元素经过hash可能命中同样的位点，这样会影响判断时候的准确率。可以想象一下，bit数组越大，hash函数散列效果越好，这样“冲突”的概率越小，判断的正确率越高。但是，扩大bit数组会占用更多内存，hash函数计算复杂度和数量会影响计算速度。所以如何平衡正确率与bit数组长度、hash函数的个数呢？有一个公式：</p>
<p>假设m是bit数组的bit的数量(长度)，k是hash函数的数量，n是在构造时元素的数量,p为判断时的错误率。则当它们满足下边两个公式时，有近似最优解。</p>
<blockquote><ol>
<li><p>m = -n * lnp / (ln2)^2 </p>
</li>
<li><p>k = m / n * ln2 </p>
</li>
</ol>
</blockquote>
<p>具体的推导过程可以看下<a href="https://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives" target="_blank" rel="external">这里。</a><br><a id="more"></a></p>
<h2 id="Guava中的实现"><a href="#Guava中的实现" class="headerlink" title="Guava中的实现"></a>Guava中的实现</h2><p>Guava中有一个BloomFilter的实现，下面来分析具体的实现方法：</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Guava的BloomFilter提供一个静态的创建方法，支持三个参数：</p>
<ol>
<li>Funnel&lt;? super T&gt;  转为PrimitiveSink的对象的类型，推荐使用enum。Funnels中支持一些基础类型，也可以自己实现。</li>
<li>expectedInsertions 预估的构造时元素的数量，即公式中的n。</li>
<li>fpp 错误率，即公式中的p，范围为0-1.0</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></div><div class="line">     Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy) &#123;</div><div class="line">   checkNotNull(funnel);</div><div class="line">   checkArgument(</div><div class="line">       expectedInsertions &gt;= <span class="number">0</span>, <span class="string">"Expected insertions (%s) must be &gt;= 0"</span>, expectedInsertions);</div><div class="line">   checkArgument(fpp &gt; <span class="number">0.0</span>, <span class="string">"False positive probability (%s) must be &gt; 0.0"</span>, fpp);</div><div class="line">   checkArgument(fpp &lt; <span class="number">1.0</span>, <span class="string">"False positive probability (%s) must be &lt; 1.0"</span>, fpp);</div><div class="line">   checkNotNull(strategy);</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (expectedInsertions == <span class="number">0</span>) &#123;</div><div class="line">     expectedInsertions = <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">//根据公式1. 计算bit数组的bit的数m</span></div><div class="line">   <span class="keyword">long</span> numBits = optimalNumOfBits(expectedInsertions, fpp);</div><div class="line">   <span class="comment">//根据公式2. 计算hash函数(执行hash次数)的数量k</span></div><div class="line">   <span class="keyword">int</span> numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">     <span class="comment">//生成bit数组，绑定hash策略（默认为MURMUR128_MITZ_64）</span></div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> BloomFilter&lt;T&gt;(<span class="keyword">new</span> BitArray(numBits), numHashFunctions, funnel, strategy);</div><div class="line">   &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Could not create BloomFilter of "</span> + numBits + <span class="string">" bits"</span>, e);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>调用BloomFilter实例的put方法来添加元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(</span></span></div><div class="line">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits) &#123;</div><div class="line">  <span class="keyword">long</span> bitSize = bits.bitSize();</div><div class="line">  <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</div><div class="line">  <span class="keyword">long</span> hash1 = lowerEight(bytes);</div><div class="line">  <span class="keyword">long</span> hash2 = upperEight(bytes);</div><div class="line"></div><div class="line">  <span class="keyword">boolean</span> bitsChanged = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">long</span> combinedHash = hash1;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; i++) &#123;</div><div class="line">    <span class="comment">// Make the combined hash positive and indexable</span></div><div class="line">    <span class="comment">//这里先和Long最大值与去掉符号位，模bit数组长度来定位，然后尝试将这位置1。最后加上Hashing.murmur3_128()结果的高8位后循环执行刚才过程。</span></div><div class="line">    bitsChanged |= bits.set((combinedHash &amp; Long.MAX_VALUE) % bitSize);</div><div class="line">    combinedHash += hash2;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//判断bit数组是否发生了变化，在上边循环中有一位被置为1则说明有变化，添加元素成功，返回true；否则可能之前已经添加过，或者和别的元素hash结果冲突，返回false;</span></div><div class="line">  <span class="keyword">return</span> bitsChanged;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>可见Guava中BloomFilter的实现并不是真正用了多种hash函数，而是通过加法和取模实现再hash。</p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>判断过程和添加过程类似，当有一个应该为1的位为0，则这个元素肯定不在集合中，直接返回false。因为有一定误判率p，所以函数名为mightContain：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(</span></span></div><div class="line">        T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits) &#123;</div><div class="line">      <span class="keyword">long</span> bitSize = bits.bitSize();</div><div class="line">      <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</div><div class="line">      <span class="keyword">long</span> hash1 = lowerEight(bytes);</div><div class="line">      <span class="keyword">long</span> hash2 = upperEight(bytes);</div><div class="line"></div><div class="line">      <span class="keyword">long</span> combinedHash = hash1;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; i++) &#123;</div><div class="line">        <span class="comment">// Make the combined hash positive and indexable</span></div><div class="line">        <span class="keyword">if</span> (!bits.get((combinedHash &amp; Long.MAX_VALUE) % bitSize)) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        combinedHash += hash2;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<h2 id="在工程中的应用"><a href="#在工程中的应用" class="headerlink" title="在工程中的应用"></a>在工程中的应用</h2><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>BloomFilter常用在爬虫系统中的url去重，可以节省大量内存空间。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>BloomFilter可以挡在系统的最前边，进行流量有效性的判断和过滤。如果判断不是此系统的业务则直接丢弃，减轻服务压力。理想情况下，流量经过的组件的顺序是这样的:BloomFilter-&gt;本地缓存-&gt;远端缓存-&gt;db，中间每个环节都可以命中并返回，减轻对后边的压力。</p>
<h3 id="关键词过滤"><a href="#关键词过滤" class="headerlink" title="关键词过滤"></a>关键词过滤</h3><p>BloomFilter可以支持keyword filter。英文文章有自然的空格字符分词，所以可以直接将敏感词库建立BloomFilter，对文章进行过滤。但是中文就有点尴尬了，只能使用多模式匹配(AC自动机、 Wu-Manber等)的精确算法来进行过滤了。</p>
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>对于分布式系统来说，每台机器上都会有自己的BloomFilter。每个BloomFilter都有自己的版本号，它们需要定时去一个统一的数据源(db或者文件)中load数据，并拿远端的版本号和自己本地版本号进行对比:如果相同则直接跳过，如果不同则需要拿远端数据进行增量构建；同时还需要定时在系统负载低时进行全量构建，保障所有机器上BloomFilter的有效性和正确性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BloomFilter简介&quot;&gt;&lt;a href=&quot;#BloomFilter简介&quot; class=&quot;headerlink&quot; title=&quot;BloomFilter简介&quot;&gt;&lt;/a&gt;BloomFilter简介&lt;/h2&gt;&lt;p&gt;BloomFilter是一个可以快速判断一个元素是否在一个集合中的组件，它的设计也比较容易理解：构建的时候，一个元素经过几个hash函数hash后，命中一个bit数组的不同的位点，并把位点置为1。在判断的时候，也要执行同样的hash函数，只要有一个没有命中则这个元素一定不存在；否则有可能存在。只会有一种“误判”的情况：元素不在集合中，但被判断为在集合中。&lt;/p&gt;
&lt;p&gt;因为构建时候多个元素经过hash可能命中同样的位点，这样会影响判断时候的准确率。可以想象一下，bit数组越大，hash函数散列效果越好，这样“冲突”的概率越小，判断的正确率越高。但是，扩大bit数组会占用更多内存，hash函数计算复杂度和数量会影响计算速度。所以如何平衡正确率与bit数组长度、hash函数的个数呢？有一个公式：&lt;/p&gt;
&lt;p&gt;假设m是bit数组的bit的数量(长度)，k是hash函数的数量，n是在构造时元素的数量,p为判断时的错误率。则当它们满足下边两个公式时，有近似最优解。&lt;/p&gt;
&lt;blockquote&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;m = -n * lnp / (ln2)^2 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;k = m / n * ln2 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的推导过程可以看下&lt;a href=&quot;https://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives&quot;&gt;这里。&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后台" scheme="https://majiaji.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="Guava" scheme="https://majiaji.github.io/tags/Guava/"/>
    
      <category term="后台" scheme="https://majiaji.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>httpClient参数设置</title>
    <link href="https://majiaji.github.io/2016/12/03/httpClient%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"/>
    <id>https://majiaji.github.io/2016/12/03/httpClient参数设置/</id>
    <published>2016-12-02T17:27:28.000Z</published>
    <updated>2016-12-04T06:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>httpClient是一个不考虑向下兼容的库，从3.x到4.x,几乎每个版本都有较大差异。本文使用的是4.5.2。</p>
<p>httpClient是一个比较常用的库，客户端使用它，或者以它为底层的网络库来向服务端发http请求。通常为了简单，每次需要请求的时候都会new一个HttpClient实例出来，拿到结果后再close掉这个实例。</p>
<p>但是对于服务端来说，在高并发的时候，每次new实例出来，在性能上是不可接受的。所以考虑所有的请求只用一个httpClient实例来搞定，这时候就需要好好check下这个httpClient的参数。</p>
<a id="more"></a>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> HttpClient httpClient;</div><div class="line"></div><div class="line">   <span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//连接池配置</span></div><div class="line">        PoolingHttpClientConnectionManager connectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager();</div><div class="line">        <span class="comment">//最大并发连接数</span></div><div class="line">        connectionManager.setMaxTotal(<span class="number">500</span>);</div><div class="line">        <span class="comment">//每个url支持的并发连接数</span></div><div class="line">        connectionManager.setDefaultMaxPerRoute(<span class="number">200</span>);</div><div class="line">        <span class="comment">//超时配置</span></div><div class="line">        RequestConfig requestConfig = RequestConfig.custom()</div><div class="line">                <span class="comment">//从连接池中取连接</span></div><div class="line">                .setConnectionRequestTimeout(<span class="number">1000</span>)</div><div class="line">                <span class="comment">//进行连接</span></div><div class="line">                .setConnectTimeout(<span class="number">5000</span>)</div><div class="line">                <span class="comment">//socket读</span></div><div class="line">                .setSocketTimeout(<span class="number">5000</span>).build();</div><div class="line">        httpClient = HttpClients.custom()</div><div class="line">                .setDefaultRequestConfig(requestConfig)</div><div class="line">                .setConnectionManager(connectionManager)</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>默认情况下，Per default this implementation will create no more than than 2 concurrent connections per given route and no more 20 connections in total。所以需要设置下总的连接数和每个route支持的连接数，否则当并发量大时，从连接池中取连接时会取不到，导致请求失败。</p>
<p>使用httpClient最怕发生阻塞且没有超时返回的情况，所以需要根据自己的需求配置三个超时时间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;httpClient是一个不考虑向下兼容的库，从3.x到4.x,几乎每个版本都有较大差异。本文使用的是4.5.2。&lt;/p&gt;
&lt;p&gt;httpClient是一个比较常用的库，客户端使用它，或者以它为底层的网络库来向服务端发http请求。通常为了简单，每次需要请求的时候都会new一个HttpClient实例出来，拿到结果后再close掉这个实例。&lt;/p&gt;
&lt;p&gt;但是对于服务端来说，在高并发的时候，每次new实例出来，在性能上是不可接受的。所以考虑所有的请求只用一个httpClient实例来搞定，这时候就需要好好check下这个httpClient的参数。&lt;/p&gt;
    
    </summary>
    
      <category term="后台" scheme="https://majiaji.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="后台" scheme="https://majiaji.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
      <category term="httpClient" scheme="https://majiaji.github.io/tags/httpClient/"/>
    
  </entry>
  
  <entry>
    <title>前端开发的浮光掠影</title>
    <link href="https://majiaji.github.io/2016/11/23/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E6%B5%AE%E5%85%89%E6%8E%A0%E5%BD%B1/"/>
    <id>https://majiaji.github.io/2016/11/23/前端开发的浮光掠影/</id>
    <published>2016-11-22T16:04:18.000Z</published>
    <updated>2016-11-26T11:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间有个比较🔥的文章 <a href="https://zhuanlan.zhihu.com/p/22782487" target="_blank" rel="external">在2016年学JavaScript是一种什么样的体验</a> 读完之后深深感受到了前端同学的痛点：用好各种框架、脚手架已经让人应接不暇了，与此同时还要不停地造自己的小轮子，着实不易。</p>
<p>在大学的有段时间，我也考虑过去做前端。因为所见即所得的东西还是很容易给人成就感的。后来只坚持学了半个学期就放弃了，主要因为一直没有搞懂，也记不住各种css标签的含义，这样导致每次在调样式的时候都无比捉急，连最基础的还原视觉稿都做不到。于是又悻悻的回到了黑框框的后端世界。</p>
<p>正式工作后也有机会接触一些前端的工作，在工作之余我总结了自己常用的开发模式和套路，分享给大家：</p>
<a id="more"></a>
<h2 id="Velocity-jQuery-Bootstrap"><a href="#Velocity-jQuery-Bootstrap" class="headerlink" title="Velocity + jQuery + Bootstrap"></a>Velocity + jQuery + Bootstrap</h2><p>这个用的是最多的。Velocity结合springMVC一起使用，在Controller前，把对象塞到一个modelMap中，然后由VelocityEngine根据vm模板去渲染，然后再返回给浏览器。之后前端页面的业务逻辑通过ajax请求后端接口，然后用jQuery直接操作dom节点修改，简单粗暴。</p>
<p>这个套路是比较简单也比较常用的，但是有一个问题，如果从0开始搭建一个系统的前端框架那么要怎么做才好呢？header啊sidebar啊布局啊还是不知道如何下手。这时候可以用下 <a href="http://www.bootcss.com/p/layoutit" target="_blank" rel="external">Bootstrap可视化布局系统</a> 可以用这个工具直接拖出来想要的前端栅格布局、导航栏、边栏二级导航（如果需要)、footer等，不满意的细节可以把它down下来自己手动修改一下，需要的组件可以到 <a href="http://www.bootcss.com/" target="_blank" rel="external">Bootstrap组件库</a>中查找。</p>
<p>Bootstrap库中的组件还是比较齐全的，而且因为使用的人很多也比较稳定，不会有什么奇怪的bug。如果不仅仅满足于这些基础的组件，还可以到<a href="http://www.jq22.com/" target="_blank" rel="external">jQuery插件库</a>中查找自己喜欢的酷炫的jQuery组件。不过这时候需要注意组件库之间有可能会冲突，引用时候要check一下。</p>
<p>总结：<br>用上述工具可以快速从零搭建起来一个前端系统框架，并进行业务开发。需要了解一下Velocity和jQuery的语法，尤其要熟练使用jQuery选择器。<br>优点：<br>符合简单的“面向过程”的开发思维，容易上手，可以快速实现需求。<br>缺点：<br>当需要动态操作大量的dom节点时候简直就是灾难：当有业务需要由ajax返回的结果决定展示什么内容时，就需要用jQuery直接操作很多dom节点。这时候就比较考眼力了，需要在各种尖括号的标签之间看清楚字符串引号是单引号还是双引号…… 而且团队中的同学也很难看明白这一坨dom标签是想干嘛，难以维护。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a href="https://vuejs.org.cn/guide/" target="_blank" rel="external">Vue</a></h2><p>Vue是在下午吃水果时听到同事提起的，回来学习了一下后发现真的是个好东西：Vue支持响应式的数据双向绑定。在使用jQuery手工操作dom时，我们的代码常常是命令式的、重复的和易错的。Vue拥抱数据驱动视图的概念，我们可以把要操作的对象声明为一个Vue对象，同时在dom标签中用特殊的占位符（双大括号）在占位，这样就进行了绑定。每次修改Vue对象，dom中的元素会响应式的更新，同样也可以实时的拿到Vue对象中的值和服务端进行交互，再也不用熟记各种花式的jQuery选择器技巧了。</p>
<p>总结：<br>Vue对于熟练Velocity的同学非常容易上手，它们都是使用了自己的标签进行占位。Vue只关注视图层，可以非常容易和jQuery、Bootstrap等其他框架共同使用。<br>优点：<br>双向绑定，与其他框架友好兼容，上手简单。<br>缺点：暂无。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a></h2><p>React是现在最🔥的前端框架。首先要转变下思维：忘掉Velocity和Vue的模板+占位符的开发方式，使用React时要把web页面中的每一部分抽象成一个“组件”，每个组件都要抽出来一个函数单独实现渲染逻辑。最后再把这些渲染逻辑像搭积木一样堆起来，再去整体进行render。</p>
<p>React中有一个非常重要的概念：状态中心，在我看来它就像是一个对外统一的接口，在渲染函数中可以用this.state取到各个属性的值，当使用this.setState修改属性值时，会进行dom diff，然后React自动调用render方法，再次渲染所有组件。</p>
<p>使用React需要了解组件的生命周期的状态和对应的处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillMount()</div><div class="line">componentDidMount()</div><div class="line">componentWillUpdate(object nextProps, object nextState)</div><div class="line">componentDidUpdate(object prevProps, object prevState)</div><div class="line">componentWillUnmount()</div></pre></td></tr></table></figure>
<p>其中通过Ajax获取服务端数据，进行初始化state的方法要放在componentDidMount()中执行。考虑性能优化时需要实现另外的状态处理函数shouldComponentUpdate()。搭建复杂的页面需要学习redux。</p>
<p>使用React可能是因为业务方觉得厂内的对React封装的那一套组件更好看一些，而且厂内的前端同学也在大力推广他们的新组件库，并且提供技术支持。但是对于后端同学来说，React似乎不是那么“友好”，需要学习理解和排坑的成本略高。遇到问题时可查询的资料不多。React不能直接简单操作dom(有麻烦的办法)，当想操作dom实现一个简单逻辑时比较困难。</p>
<p>总结：<br>React适合那种dom类型和位置都确定的复杂页面，它支持数据的单向绑定，即修改state中的属性，然后自动的进行render。对于简单的页面来说，考虑到上手难度，有点得不偿失。但是这是未来的趋势嘛，学习一下还是很有必要的。<br>优点：<br>组件化、函数式、社区活跃<br>缺点：<br>学习成本高，上手难度大，排查问题困难</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文没有讨论各种前端框架底层的实现，如Vue的底层实现和React的Virtual DOM哪个性能更好，仅仅是站在一个纯初级使用者的角度去谈谈自己在使用这些框架时的感受和理解。所以只能算是浮光掠影了。<br>如有理解错误的地方，欢迎讨论交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间有个比较🔥的文章 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/22782487&quot;&gt;在2016年学JavaScript是一种什么样的体验&lt;/a&gt; 读完之后深深感受到了前端同学的痛点：用好各种框架、脚手架已经让人应接不暇了，与此同时还要不停地造自己的小轮子，着实不易。&lt;/p&gt;
&lt;p&gt;在大学的有段时间，我也考虑过去做前端。因为所见即所得的东西还是很容易给人成就感的。后来只坚持学了半个学期就放弃了，主要因为一直没有搞懂，也记不住各种css标签的含义，这样导致每次在调样式的时候都无比捉急，连最基础的还原视觉稿都做不到。于是又悻悻的回到了黑框框的后端世界。&lt;/p&gt;
&lt;p&gt;正式工作后也有机会接触一些前端的工作，在工作之余我总结了自己常用的开发模式和套路，分享给大家：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://majiaji.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://majiaji.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://majiaji.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>啊，第一篇博客</title>
    <link href="https://majiaji.github.io/2016/11/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://majiaji.github.io/2016/11/21/第一篇博客/</id>
    <published>2016-11-21T07:06:25.000Z</published>
    <updated>2016-11-21T16:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2>为什么要写博客</h2>

<p>现在技术越来越好了，网络内容的主流媒介完成了文字-&gt;图片-&gt;视频-&gt;直播这样的转变。下班回来后，经常各种app(微信知乎头条微博等)刷一遍，来补充一下白天被抽空的精神世界。后来我发现了一个问题，对于各种网络内容来说，我一直都是一个“看客”，几乎很少去评论或者主动提出一些观点，这是一件非常可怕的事情。虽然看别人的东西也能学到很多东西，但是少了一个自己主动思考的过程。最近也在追<a href="http://www.hbo.com/westworld" target="_blank" rel="external">西部世界</a>，这算不算一种自我觉醒呢？哈哈。<br>所以打算从今天开始写博客了，可能包括自己日常生活中的感悟、吐槽和理解，还会分享一些技术知识和踩过的坑，希望能帮助到大家，也希望能认识更多的朋友。</p>
<p></p><h2>flag</h2><br>这里先立个flag，每周至少一篇详细的技术博客，坚持，共勉。<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;为什么要写博客&lt;/h2&gt;

&lt;p&gt;现在技术越来越好了，网络内容的主流媒介完成了文字-&amp;gt;图片-&amp;gt;视频-&amp;gt;直播这样的转变。下班回来后，经常各种app(微信知乎头条微博等)刷一遍，来补充一下白天被抽空的精神世界。后来我发现了一个问题，对于各种网络内容来说，我一
    
    </summary>
    
      <category term="闲谈" scheme="https://majiaji.github.io/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="闲谈" scheme="https://majiaji.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
</feed>
