<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fantasy&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://majiaji.github.io/"/>
  <updated>2017-02-13T16:44:19.000Z</updated>
  <id>https://majiaji.github.io/</id>
  
  <author>
    <name>fantasy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017年后小记</title>
    <link href="https://majiaji.github.io/2017/02/13/2017%E5%B9%B4%E5%90%8E%E5%B0%8F%E8%AE%B0/"/>
    <id>https://majiaji.github.io/2017/02/13/2017年后小记/</id>
    <published>2017-02-13T15:48:44.000Z</published>
    <updated>2017-02-13T16:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离上次写博客时间很久了，鸽了好多期啊。其实是有很多东西可以拿来分享的，只是最近实在太忙了，首先是工作上填一个历史的坑。花了年前几天包括过完年这段时间终于搞定了。重构+数据迁移+bug fix+文档沉淀。希望这个锅搞完后，也能造福同事。</p>
<p>然后就是办证，像打游戏收集任务材料一样，各种场景跑来跑去的，有的材料还必须在工作日才能爆出。大天朝的各种奇怪的材料需求和规定真是让人费解，什么时候才能刷一下身份证验证所有呢？</p>
<p>年后剁手买了第一辆小车，加上计划的日本之行，看来今年要吃很多土了。开车方面，因为是新手，说实话，自己上路还是有点胆怯的。而且在上路后才真正发现，原来这个社会上不遵守规则的人有这么多。每天也去B站看下<a href="http://space.bilibili.com/28152409/#!/index" target="_blank" rel="external">交通事故video</a>，天天嘴上念叨着的“让速不让道”，当紧急情况出现时，能临危不乱的老司机会有多少呢？</p>
<p>学习方面，主要看了一些并发方向的文章，对于原子操作和锁的底层实现有了更深一层的理解。</p>
<p>闲暇时和同事闲侃了一下现在和未来。现在：有收获也有遗憾，珍惜现在，尽力做好自己；未来：把握机遇，做好选择，持续学习。</p>
<p>从这周开始要续上断更的技术文章了，共勉！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离上次写博客时间很久了，鸽了好多期啊。其实是有很多东西可以拿来分享的，只是最近实在太忙了，首先是工作上填一个历史的坑。花了年前几天包括过完年这段时间终于搞定了。重构+数据迁移+bug fix+文档沉淀。希望这个锅搞完后，也能造福同事。&lt;/p&gt;
&lt;p&gt;然后就是办证，像打游戏
    
    </summary>
    
      <category term="闲谈" scheme="https://majiaji.github.io/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="闲谈" scheme="https://majiaji.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2016年总结</title>
    <link href="https://majiaji.github.io/2016/12/31/2016%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://majiaji.github.io/2016/12/31/2016年总结/</id>
    <published>2016-12-30T16:28:14.000Z</published>
    <updated>2017-01-03T16:13:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016年的最后一天，坐下来聊一聊和2016有关的事情和感想。</p>
<p>话说算上实习，今年已经工作两年了。一起来杭州的大学室友蛋蛋跑去了北京，我们同寝的时间定格在了五年。每次回来都会感觉不太习惯，少了一个愿意听我bb的人、愿意和我bb的人。蛋蛋是一个很善良的人，我一直担心他社会经验不足，不厌其烦的跟他聊我在北京时的一点点经验，后来发现我真是多虑了。蛋蛋到了北京后执行力爆表，迅速的找到了蛋妹，过上了幸福的生活。临走那天送给蛋蛋的祝福很快成真，也是一件很开心的事情。</p>
<p>女盆友和家人在不同的两个远方，几乎所有的假期和年假都是和他们一起度过的。经常深圳郑州两边跑，虽然路途辛苦(主要锅在hz交通)，但是能见到他们还是很开心的。新的一年希望能有时间带他们出去走走，更希望自己有能力早点在异乡有我们的家🏠。</p>
<a id="more"></a>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>工作方面，2016年自己成长了许多，最大的变化是自己面对各种问题时多了一份从容，问题解决后也会有思考和总结。只是开始写博客的时间太晚了，踩过的坑和学到的东西没有尽数记录下来。这是今年的一点小遗憾吧。</p>
<p>今年前半段时间有些浮躁，会为一些小成就而自满，放松自己。还好最近一段时间遭受了一些打击，终于能沉下心来看一些之前看不下去的书了。现在我已经非常确定了自己的发展方向，会坚持的走下去。希望自己未来能在这个领域能有所贡献。</p>
<p>感谢周围同事耐心的指导，从你们身上我学到了很多，我有了自己的榜样和看齐的对象。</p>
<p>工作是为了生活，但兴趣也是很重要的。在工作之余的时间我做了一些小组件，放在了git上。希望新的一年能多做一些更有趣的东西。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><h4 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h4><p>今年去了好多地方：杭州、绍兴、舟山、千岛湖、深圳 x 3、香港、上海、成都、广州、横店、北京、郑州 x 2、乌镇。和我同行的人，比我到的地方更重要。</p>
<p>2017年，也要考虑带妹子回家，还有去妹子家的事情了。还计划和妹子去一下日本，正在准备中。</p>
<h4 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h4><p>今年看过的觉得很赞的电影:<br>我的少女时代、火星救援、师父、寻龙诀、唐人街探案、美国队长3、死侍、科洛弗道10号、夏洛特烦恼、垫底辣妹、疯狂动物城、美人鱼、火影忍者剧场版：博人转、老炮儿、小姐、魔兽、火锅英雄、追凶者也、七月与安生、釜山行、驴得水、你的名字。</p>
<p>前段时间忽然明白为什么说“艺术是比科学更高一层的存在”了，假如不学计算机的话，我应该想去学编辑或者导演吧、或者学作曲也可以的😌……(醒一醒)</p>
<p>今年还看过两部非常棒的剧：</p>
<ol>
<li>李狗嗨(legal high)：胜利即正义！</li>
<li>西部世界(west world):Bring yourself back online.</li>
</ol>
<h4 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h4><p>今年身体比去年更差了一些（难道高中时期真的是巅峰吗），每天对着电脑，视力下降了一些。上个月有段时间每到晚上眼睛都疼睁不开，坐了很久背也会有点疼。还好体检结果没有什么大问题，比上学时候胖了一些。</p>
<p>措施：坚持每天骑车上下班🚴。每周末坚持运动，篮球或者跑步，有机会去游泳。每天争取12点前睡觉。</p>
<h3 id="2017的期待"><a href="#2017的期待" class="headerlink" title="2017的期待"></a>2017的期待</h3><p>新的一年，有很多事情要做：</p>
<ol>
<li>努力学习，点满后端技能树，并尝试进阶</li>
<li>每周至少一篇博客，技术总结 or 生活点滴</li>
<li>多回家看看，多陪陪女盆友</li>
<li>想学一门弦乐器，乌克丽丽或者吉他</li>
<li>学会做饭，能在周末自给自足</li>
<li>买个小车</li>
<li>早睡</li>
</ol>
<p>愿2017一切更好，新年快乐~~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年的最后一天，坐下来聊一聊和2016有关的事情和感想。&lt;/p&gt;
&lt;p&gt;话说算上实习，今年已经工作两年了。一起来杭州的大学室友蛋蛋跑去了北京，我们同寝的时间定格在了五年。每次回来都会感觉不太习惯，少了一个愿意听我bb的人、愿意和我bb的人。蛋蛋是一个很善良的人，我一直担心他社会经验不足，不厌其烦的跟他聊我在北京时的一点点经验，后来发现我真是多虑了。蛋蛋到了北京后执行力爆表，迅速的找到了蛋妹，过上了幸福的生活。临走那天送给蛋蛋的祝福很快成真，也是一件很开心的事情。&lt;/p&gt;
&lt;p&gt;女盆友和家人在不同的两个远方，几乎所有的假期和年假都是和他们一起度过的。经常深圳郑州两边跑，虽然路途辛苦(主要锅在hz交通)，但是能见到他们还是很开心的。新的一年希望能有时间带他们出去走走，更希望自己有能力早点在异乡有我们的家🏠。&lt;/p&gt;
    
    </summary>
    
      <category term="闲谈" scheme="https://majiaji.github.io/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="闲谈" scheme="https://majiaji.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>理解回调机制</title>
    <link href="https://majiaji.github.io/2016/12/25/%E7%90%86%E8%A7%A3%E5%9B%9E%E8%B0%83/"/>
    <id>https://majiaji.github.io/2016/12/25/理解回调/</id>
    <published>2016-12-25T11:27:57.000Z</published>
    <updated>2016-12-25T15:59:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对回调的理解"><a href="#对回调的理解" class="headerlink" title="对回调的理解"></a>对回调的理解</h3><p>之前回调用的比较少，一直理解为观察者模式。最近思考了一波，回调并不能和某种设计模式绑定在一起，它其实只是一种通用的写法。</p>
<p>举个例子：有两个类A和B，B是A的属性，A可以通过函数调用B的方法，同时把自己作为参数传递到B的方法中，B的方法在完成时可以调用A的函数，这就是回调。如果A在调用B的方法时同步等待，则是同步回调；否则即为异步回调。A的引用可以作为方法参数带入B中，也可以放到ThreadLocal中进行传递。下边是具体例子的代码：</p>
<a id="more"></a>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>首先定义一个接口ICallBack：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICallBack</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<p>A类要实现这个接口，同时A中有B的引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">ICallBack</span> </span>&#123;</div><div class="line">    B b = <span class="keyword">new</span> B();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doBizSync</span><span class="params">()</span> </span>&#123;</div><div class="line">        b.remoteCall(<span class="keyword">this</span>);</div><div class="line">        System.out.println(<span class="string">"doBizSync return"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doBizAsync</span><span class="params">()</span> </span>&#123;</div><div class="line">        A temp = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            b.remoteCall(temp);</div><div class="line">        &#125;).start();</div><div class="line">        System.out.println(<span class="string">"doBizAsync return"</span>);</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"call back completed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>A有两个业务函数，分别用来测试同步和异步回调。</p>
<p>下边是类B的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">remoteCall</span><span class="params">(A a)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"this will cost 5 secodes..."</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">5000L</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        a.onComplete();</div><div class="line">        <span class="keyword">synchronized</span> (a) &#123;</div><div class="line">            a.notify();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="string">"remoteCall complete"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>类B中用remoteCall函数来模拟远程调用的场景。在真实场景中，B为一个注入到A的service bean。</p>
<p>测试类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> </span>&#123;</div><div class="line">        A a = <span class="keyword">new</span> A();</div><div class="line">        a.doBizSync();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//结果：</span></div><div class="line">    <span class="comment">//this will cost 5 secodes...</span></div><div class="line">    <span class="comment">//call back completed</span></div><div class="line">    <span class="comment">//doBizSync return</span></div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> </span>&#123;</div><div class="line">        A a = <span class="keyword">new</span> A();</div><div class="line">        a.doBizAsync();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//结果：</span></div><div class="line">    <span class="comment">//doBizAsync return</span></div><div class="line">    <span class="comment">//this will cost 5 secodes...</span></div><div class="line">    <span class="comment">//call back completed</span></div><div class="line"></div></pre></td></tr></table></figure><br>可见异步回调中当前线程不用一直等待远程方法返回，可以去处理其他业务了。这种写法可以节省线程池资源，提高并发。当回调处理函数只有一个时，ICallBack也可以省去了，可以用lambda表达式来代替。</p>
<h3 id="Servlet-3-0开启异步"><a href="#Servlet-3-0开启异步" class="headerlink" title="Servlet 3.0开启异步"></a>Servlet 3.0开启异步</h3><p>Servlet 3.0支持开启异步，这样可以实现客户端和服务端的连接还在，Servlet中的线程就不用阻塞的等待在这里了，可以释放出来去做别的事情。代码例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletAsyncTestController</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncAjax</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">final</span> PrintWriter writer = response.getWriter();</div><div class="line">        writer.println(<span class="string">"first message....\r\n"</span>);</div><div class="line">        request.setAttribute(<span class="string">"org.apache.catalina.ASYNC_SUPPORTED"</span>, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">final</span> AsyncContext asyncContext = request.startAsync(request, response);</div><div class="line">        asyncContext.setTimeout(<span class="number">100000</span>); <span class="comment">//测试设置超时时间</span></div><div class="line">        asyncContext.start(() -&gt; &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                writer.println(<span class="string">"hi.....\r\n"</span>);</div><div class="line">            &#125;</div><div class="line">            asyncContext.complete();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>业务线程做完耗时业务后，调用asyncContext.complete()，客户端就能收到返回了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对回调的理解&quot;&gt;&lt;a href=&quot;#对回调的理解&quot; class=&quot;headerlink&quot; title=&quot;对回调的理解&quot;&gt;&lt;/a&gt;对回调的理解&lt;/h3&gt;&lt;p&gt;之前回调用的比较少，一直理解为观察者模式。最近思考了一波，回调并不能和某种设计模式绑定在一起，它其实只是一种通用的写法。&lt;/p&gt;
&lt;p&gt;举个例子：有两个类A和B，B是A的属性，A可以通过函数调用B的方法，同时把自己作为参数传递到B的方法中，B的方法在完成时可以调用A的函数，这就是回调。如果A在调用B的方法时同步等待，则是同步回调；否则即为异步回调。A的引用可以作为方法参数带入B中，也可以放到ThreadLocal中进行传递。下边是具体例子的代码：&lt;/p&gt;
    
    </summary>
    
      <category term="后台" scheme="https://majiaji.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="后台" scheme="https://majiaji.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>长连接通道解决方案</title>
    <link href="https://majiaji.github.io/2016/12/24/%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%80%9A%E9%81%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://majiaji.github.io/2016/12/24/长连接通道解决方案/</id>
    <published>2016-12-24T06:27:07.000Z</published>
    <updated>2016-12-25T06:31:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要长连接"><a href="#为什么要长连接" class="headerlink" title="为什么要长连接"></a>为什么要长连接</h2><h3 id="资源中心or控制中心"><a href="#资源中心or控制中心" class="headerlink" title="资源中心or控制中心"></a>资源中心or控制中心</h3><p>很久以来，服务端一直作为“统一资源中心”而存在，所以后台开发工程师们的基础工作就是存储、维护和管理用户的数据，然后开接口给客户端&amp;&amp;前端同学使用。后来出现了restful架构风格：一个URI代表一个资源，客户端用HTTP协议的操作方式（GET、POST、PUT、DELETE）对资源进行操作，即完成了与服务端的交互。这样的设计可以让服务端的逻辑变得非常的轻，真的变成了“资源中心”了。客户端可以依托操作资源的接口去实现真正的业务逻辑，渲染界面。考虑到一些异常情况处理，逻辑会做的比较重。</p>
<p>对于后台开发同学来说，一定不会满足于“资源管理者”这样的角色，每天写写增删改查和字符串拼接。因为有长连接技术的存在，服务端可以做更多的事情。相对于客户端把服务端当成“数据资源库”，反过来，服务端也可以把客户端看成“UI库”，通过长连接通道推送命令下去，指导客户端UI进行变化。这样服务端就从“资源中心”变成了“控制中心”。当然这是一种比较极端的设计，长连接可能因为网络或者客户端环境问题断掉，这样控制中心就失去控制能力了。所以在实现业务时可以用推拉结合的模式。</p>
<h3 id="即时触达的能力"><a href="#即时触达的能力" class="headerlink" title="即时触达的能力"></a>即时触达的能力</h3><p>因为有了长连接通道，服务端有了消息即时触达的能力，同时避免了客户端分布式攻击式的轮询。这个能力是非常非常重要的，在设计在线网络游戏、IM系统、推送系统时长连接通道不可或缺。</p>
<h3 id="业界通用推送方法"><a href="#业界通用推送方法" class="headerlink" title="业界通用推送方法"></a>业界通用推送方法</h3><p>现在移动端都有自己的push系统，iOS有<a href="https://developer.apple.com/notifications/" target="_blank" rel="external">APNS(Apple Push Notification service)</a>,Android有<a href="https://developers.google.com/cloud-messaging/?hl=zh-cn/" target="_blank" rel="external">GCM(Google Cloud Messaging)</a>。可以简单理解为官方的一个服务和移动客户端建立了一个长连接，所有的app共用这条通道，每次推送时要用自己的服务调用一下官方服务的接口，然后由官方的服务进行推送，客户端收到推送后会在系统通知栏看到app推送的一个概要信息，用户点击这条push,会唤起对应的app，进入app后会调用app自己的服务接口拉取更多的业务数据。</p>
<p>因为哈哈哈哈的原因，GCM在国内几乎不能使用；如果应用有pc端还要支持pc端的推送;业务比较复杂时会希望设计一种更高效灵活的推送协议。基于以上原因，开发者会设计自己的长连接通道和推送协议。</p>
<a id="more"></a>
<h2 id="客户端长连接方案"><a href="#客户端长连接方案" class="headerlink" title="客户端长连接方案"></a>客户端长连接方案</h2><p>下边给大家介绍一款轻量级的长连接&amp;&amp;推送框架(依赖netty4.1.2) <a href="https://github.com/majiaji/rivendell" target="_blank" rel="external">rivendell</a>，名字出自《the Lord of the Rings》。</p>
<h3 id="框架特性"><a href="#框架特性" class="headerlink" title="框架特性"></a>框架特性</h3><ul>
<li>长连接管理</li>
</ul>
<p>map存储channel id和ChannelHandlerContext。方便对在线用户进行管理。</p>
<ul>
<li>业务异步化</li>
</ul>
<p>默认情况下，netty是有1个boss线程来accept连接，然后分给availableProcessors*2个worker线程进行处理。为个提高并发量，这几个worker线程是不能去做耗时的业务操作的。在这里worker线程只做编解码，然后根据协议的action，分发到线程池中异步执行相应任务。</p>
<ul>
<li>断线重连</li>
</ul>
<p>长连接的保活是非常重要的工作，在这里的实现是客户端监听IdleStateEvent事件，每10s发送心跳包，服务端收到心跳包后会echo给客户端；当客户端25s没有收到读消息则触发断线重连。</p>
<ul>
<li>扩展性</li>
</ul>
<p>定义了简单的协议SimpleProtocol:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> success;(本次动作是否成功)</div><div class="line"><span class="keyword">private</span> String action;(动作类型)</div><div class="line"><span class="keyword">private</span> String content;(动作内容)</div></pre></td></tr></table></figure></p>
<p>可以基于此协议实现自己的业务，需要实现IActionHandler接口,当然也可以定义自己的协议。</p>
<ul>
<li>监控&amp;&amp;推送后台</li>
</ul>
<p>可以看到实时长连接数，并提供了推送入口。支持单点推送和广播。</p>
<h3 id="代码路径"><a href="#代码路径" class="headerlink" title="代码路径"></a>代码路径</h3><p>服务端相关代码在com.fantasy.rivendell.service.server包中，客户端相关代码在com.fantasy.rivendell.service.client包中，控制台的入口类是RivendellController。如果有问题欢迎找我讨论😆。</p>
<h2 id="浏览器长连接方案"><a href="#浏览器长连接方案" class="headerlink" title="浏览器长连接方案"></a>浏览器长连接方案</h2><p>浏览器实现长连接，自然想到了<a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="external">websocket</a>。这里就不介绍websocket是如何交换sec-key如何upgrade协议了，只讲下具体实现方案：</p>
<h3 id="原生实现"><a href="#原生实现" class="headerlink" title="原生实现"></a>原生实现</h3><p>依赖tomcat容器7.0.47以上版本，并且需要引入包：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;javax.websocket&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1&lt;/version&gt;</div><div class="line">    &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>在Websocket处理类上加注解@ServerEndpoint(“/websocket路径”)后，监听onOpen、onMessage、onClose时间即可。每次一个新的会话都会创建一个新的本类的实例。比较尴尬的是，这种方式和Spring是不兼容的，不能同时使用Spring进行bean的管理。</p>
<h3 id="spring中的实现"><a href="#spring中的实现" class="headerlink" title="spring中的实现"></a>spring中的实现</h3><p>首先引入spring websocket相关的包：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><br>继承WebSocketConfigurer类，配置websocket入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebSocket</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</div><div class="line">        registry.addHandler(renjuHandler(), <span class="string">"/入口路径"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">bizHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BizHandler();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>业务逻辑写在BizHandler中，BizHandler可以继承TextWebSocketHandler，重载父类处理函数。注意，这里的BizHandler是一个被spring管理的bean，这样就可以愉快的进行注入了。</p>
<p>浏览器端直接用html5中的Websocket就行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> connection = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8080/入口路径"</span>);</div><div class="line">connection.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">do</span> some biz...</div><div class="line">&#125;</div><div class="line">connection.onmessage= <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="keyword">do</span> some biz...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>最后附上一个使用websocket实现的在线五子棋游戏demo:<a href="https://github.com/majiaji/renju" target="_blank" rel="external">renju</a></p>
<h2 id="思考和总结"><a href="#思考和总结" class="headerlink" title="思考和总结"></a>思考和总结</h2><h3 id="分布式环境"><a href="#分布式环境" class="headerlink" title="分布式环境"></a>分布式环境</h3><p>单台服务器可打开的最大连接数是有限的，当用户量比较大时需要提供一个集群来给用户建立长连接。同时还需要一个位置服务：用户来连接时经过一致性hash计算落到某台机器上，记录在位置服务中；要推送时要首先查询位置服务，拿到用户此时连在哪台机器，之后向这个机器投递消息，进行推送。</p>
<h3 id="长连接安全问题"><a href="#长连接安全问题" class="headerlink" title="长连接安全问题"></a>长连接安全问题</h3><p>攻击者和长连接服务建立tcp连接，这一步是没有办法校验的，所以对于syn flood攻击需要其他机制来防御。建立连接后可以用非对称加密来交换对称加密的秘钥，之后经过对称秘钥加密解密进行传输。对于服务端来说，如果收到无法识别，或者解密失败的消息，直接丢弃。</p>
<h3 id="长连接作为代理"><a href="#长连接作为代理" class="headerlink" title="长连接作为代理"></a>长连接作为代理</h3><p>通过长连接代理请求后端服务，可以避免创建socket和三次握手的消耗，提高性能。</p>
<h3 id="长连接保活机制"><a href="#长连接保活机制" class="headerlink" title="长连接保活机制"></a>长连接保活机制</h3><p>长连接如果不存在了有两种表现：1是再使用这个通道时会收到异常；2是发送的心跳包超过一定时间没有响应。所以判断长连接是否存在需要有具体的机制来触发监测，看是否会出现这两种表现。本文中rivendell项目实现的是由客户端主动发起心跳监测，服务端收到心跳校测后echo给客户端，客户端根据拿到echo后重置IdleState。服务端要有一个时间轮来管理所有连接，及时清理掉不存在的连接的上下文。</p>
<p>当客户端判断连接真的不存在时，要有一定的退避机制，不能立刻重连。</p>
<h3 id="websocket和http2"><a href="#websocket和http2" class="headerlink" title="websocket和http2"></a>websocket和http2</h3><p>http2的特性中有一条是支持server push，那么http2是否可以取代websocket呢？答案是否定的。http2为了提高性能也有一个持久的连接，它鼓励服务端尽量长久的维持这个连接，但是也允许服务端在必要时刻关掉idle的连接。所以http2并不能取代websocket，它们可以互相补充。</p>
<p>有任何问题，欢迎留言或者邮件交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要长连接&quot;&gt;&lt;a href=&quot;#为什么要长连接&quot; class=&quot;headerlink&quot; title=&quot;为什么要长连接&quot;&gt;&lt;/a&gt;为什么要长连接&lt;/h2&gt;&lt;h3 id=&quot;资源中心or控制中心&quot;&gt;&lt;a href=&quot;#资源中心or控制中心&quot; class=&quot;headerlink&quot; title=&quot;资源中心or控制中心&quot;&gt;&lt;/a&gt;资源中心or控制中心&lt;/h3&gt;&lt;p&gt;很久以来，服务端一直作为“统一资源中心”而存在，所以后台开发工程师们的基础工作就是存储、维护和管理用户的数据，然后开接口给客户端&amp;amp;&amp;amp;前端同学使用。后来出现了restful架构风格：一个URI代表一个资源，客户端用HTTP协议的操作方式（GET、POST、PUT、DELETE）对资源进行操作，即完成了与服务端的交互。这样的设计可以让服务端的逻辑变得非常的轻，真的变成了“资源中心”了。客户端可以依托操作资源的接口去实现真正的业务逻辑，渲染界面。考虑到一些异常情况处理，逻辑会做的比较重。&lt;/p&gt;
&lt;p&gt;对于后台开发同学来说，一定不会满足于“资源管理者”这样的角色，每天写写增删改查和字符串拼接。因为有长连接技术的存在，服务端可以做更多的事情。相对于客户端把服务端当成“数据资源库”，反过来，服务端也可以把客户端看成“UI库”，通过长连接通道推送命令下去，指导客户端UI进行变化。这样服务端就从“资源中心”变成了“控制中心”。当然这是一种比较极端的设计，长连接可能因为网络或者客户端环境问题断掉，这样控制中心就失去控制能力了。所以在实现业务时可以用推拉结合的模式。&lt;/p&gt;
&lt;h3 id=&quot;即时触达的能力&quot;&gt;&lt;a href=&quot;#即时触达的能力&quot; class=&quot;headerlink&quot; title=&quot;即时触达的能力&quot;&gt;&lt;/a&gt;即时触达的能力&lt;/h3&gt;&lt;p&gt;因为有了长连接通道，服务端有了消息即时触达的能力，同时避免了客户端分布式攻击式的轮询。这个能力是非常非常重要的，在设计在线网络游戏、IM系统、推送系统时长连接通道不可或缺。&lt;/p&gt;
&lt;h3 id=&quot;业界通用推送方法&quot;&gt;&lt;a href=&quot;#业界通用推送方法&quot; class=&quot;headerlink&quot; title=&quot;业界通用推送方法&quot;&gt;&lt;/a&gt;业界通用推送方法&lt;/h3&gt;&lt;p&gt;现在移动端都有自己的push系统，iOS有&lt;a href=&quot;https://developer.apple.com/notifications/&quot;&gt;APNS(Apple Push Notification service)&lt;/a&gt;,Android有&lt;a href=&quot;https://developers.google.com/cloud-messaging/?hl=zh-cn/&quot;&gt;GCM(Google Cloud Messaging)&lt;/a&gt;。可以简单理解为官方的一个服务和移动客户端建立了一个长连接，所有的app共用这条通道，每次推送时要用自己的服务调用一下官方服务的接口，然后由官方的服务进行推送，客户端收到推送后会在系统通知栏看到app推送的一个概要信息，用户点击这条push,会唤起对应的app，进入app后会调用app自己的服务接口拉取更多的业务数据。&lt;/p&gt;
&lt;p&gt;因为哈哈哈哈的原因，GCM在国内几乎不能使用；如果应用有pc端还要支持pc端的推送;业务比较复杂时会希望设计一种更高效灵活的推送协议。基于以上原因，开发者会设计自己的长连接通道和推送协议。&lt;/p&gt;
    
    </summary>
    
      <category term="后台" scheme="https://majiaji.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="后台" scheme="https://majiaji.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
      <category term="长连接" scheme="https://majiaji.github.io/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="推送" scheme="https://majiaji.github.io/tags/%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Guava Cache</title>
    <link href="https://majiaji.github.io/2016/12/11/Guava-Cache/"/>
    <id>https://majiaji.github.io/2016/12/11/Guava-Cache/</id>
    <published>2016-12-11T05:31:42.000Z</published>
    <updated>2016-12-11T17:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guava-Cache简介"><a href="#Guava-Cache简介" class="headerlink" title="Guava Cache简介"></a>Guava Cache简介</h2><p>Local Cache是比较常用的后端开发“组件”，Guava中的Cache是一个很实用的Local Cache的实现，它支持下列特性：</p>
<ul>
<li>automatic loading of entries into the cache</li>
<li>least-recently-used eviction when a maximum size is exceeded</li>
<li>time-based expiration of entries, measured since last access or last write</li>
<li>keys automatically wrapped in weak references</li>
<li>values automatically wrapped in weak or soft references</li>
<li>notification of evicted (or otherwise removed) entries</li>
<li>accumulation of cache access statistics</li>
</ul>
<p>这些特性都是可选的，可在初始化时的建造者模式中进行配置。<br>今天主要根据源码来讲一下Guava Cache（19.0）的实现，具体的应用方法可以参考<a href="https://github.com/google/guava/wiki/CachesExplained" target="_blank" rel="external">官方文档</a>。</p>
<a id="more"></a>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="“过期”策略介绍"><a href="#“过期”策略介绍" class="headerlink" title="“过期”策略介绍"></a>“过期”策略介绍</h3><p>在讲源码之前首先介绍两个常用的过期策略：expireAfterWrite和refreshAfterWrite。这两个策略都能保证在本地缓存过期时，只有一个线程去加载后端资源（远端缓存或者db)。不同的是，在加载资源时，expireAfterWrite会让所有的线程阻塞等待新值返回,然后返回加载好的新值；而refreshAfterWrite在一个线程去拿新值的同时，其他线程先直接返回旧值，不阻塞。</p>
<p>get方法主要实现了上述逻辑。</p>
<h3 id="get分析"><a href="#get分析" class="headerlink" title="get分析"></a>get分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// loading</span></div><div class="line"></div><div class="line">     <span class="function">V <span class="title">get</span><span class="params">(K key, <span class="keyword">int</span> hash, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</div><div class="line">      checkNotNull(key);</div><div class="line">      checkNotNull(loader);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//count是这个segment中“存活”的元素数量，第一次命中时为0</span></div><div class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123; <span class="comment">// read-volatile</span></div><div class="line">          <span class="comment">// don't call getLiveEntry, which would ignore loading values</span></div><div class="line">          ReferenceEntry&lt;K, V&gt; e = getEntry(key, hash);</div><div class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">long</span> now = map.ticker.read();</div><div class="line">            <span class="comment">//获取有效的，且没有过期的值</span></div><div class="line">            V value = getLiveValue(e, now);</div><div class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">//CacheStats打点记录</span></div><div class="line">              recordRead(e, now);</div><div class="line">              statsCounter.recordHits(<span class="number">1</span>);</div><div class="line">              <span class="comment">//refresh的逻辑，不阻塞先返回旧值</span></div><div class="line">              <span class="keyword">return</span> scheduleRefresh(e, key, hash, value, now, loader);</div><div class="line">            &#125;</div><div class="line">            ValueReference&lt;K, V&gt; valueReference = e.getValueReference();</div><div class="line">            <span class="keyword">if</span> (valueReference.isLoading()) &#123;</div><div class="line">              <span class="comment">//已经有一个线程去load了，这里同步等待返回的新值</span></div><div class="line">              <span class="keyword">return</span> waitForLoadingValue(e, key, valueReference);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// at this point e is either null or expired;</span></div><div class="line">        <span class="comment">//拿锁并返回已经存在的值，或者进行同步的load</span></div><div class="line">        <span class="keyword">return</span> lockedGetOrLoad(key, hash, loader);</div><div class="line">      &#125; <span class="keyword">catch</span> (ExecutionException ee) &#123;</div><div class="line">        Throwable cause = ee.getCause();</div><div class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionError((Error) cause);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedExecutionException(cause);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> ee;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        postReadCleanup();</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>get中的scheduleRefresh:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">V <span class="title">scheduleRefresh</span><span class="params">(ReferenceEntry&lt;K, V&gt; entry, K key, <span class="keyword">int</span> hash, V oldValue, <span class="keyword">long</span> now,</span></span></div><div class="line">       CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader) &#123;</div><div class="line">     <span class="keyword">if</span> (map.refreshes() &amp;&amp; (now - entry.getWriteTime() &gt; map.refreshNanos)</div><div class="line">         &amp;&amp; !entry.getValueReference().isLoading()) &#123;</div><div class="line">         <span class="comment">//如果没有线程在loading，则去load新值</span></div><div class="line">       V newValue = refresh(key, hash, loader, <span class="keyword">true</span>);</div><div class="line">       <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">return</span> newValue;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//否则直接返回旧值</span></div><div class="line">     <span class="keyword">return</span> oldValue;</div><div class="line">   &#125;</div><div class="line"></div></pre></td></tr></table></figure><br>get中的lockedGetOrLoad:<br>一般第一次加载某个key对应的value，或者expireAfterWrite策略中value过期时会进入到这个函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function">V <span class="title">lockedGetOrLoad</span><span class="params">(K key, <span class="keyword">int</span> hash, CacheLoader&lt;? <span class="keyword">super</span> K, V&gt; loader)</span></span></div><div class="line">        <span class="keyword">throws</span> ExecutionException &#123;</div><div class="line">      ReferenceEntry&lt;K, V&gt; e;</div><div class="line">      ValueReference&lt;K, V&gt; valueReference = <span class="keyword">null</span>;</div><div class="line">      LoadingValueReference&lt;K, V&gt; loadingValueReference = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">boolean</span> createNewEntry = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">      lock();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// re-read ticker once inside the lock</span></div><div class="line">        <span class="keyword">long</span> now = map.ticker.read();</div><div class="line">        preWriteCleanup(now);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> newCount = <span class="keyword">this</span>.count - <span class="number">1</span>;</div><div class="line">        AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = <span class="keyword">this</span>.table;</div><div class="line">        <span class="keyword">int</span> index = hash &amp; (table.length() - <span class="number">1</span>);</div><div class="line">        ReferenceEntry&lt;K, V&gt; first = table.get(index);</div><div class="line"></div><div class="line">        <span class="comment">//找到元素判断是否过期，返回或者执行清理</span></div><div class="line">        <span class="keyword">for</span> (e = first; e != <span class="keyword">null</span>; e = e.getNext()) &#123;</div><div class="line">          K entryKey = e.getKey();</div><div class="line">          <span class="keyword">if</span> (e.getHash() == hash &amp;&amp; entryKey != <span class="keyword">null</span></div><div class="line">              &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) &#123;</div><div class="line">            valueReference = e.getValueReference();</div><div class="line">            <span class="keyword">if</span> (valueReference.isLoading()) &#123;</div><div class="line">              createNewEntry = <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              V value = valueReference.get();</div><div class="line">              <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">                enqueueNotification(entryKey, hash, valueReference, RemovalCause.COLLECTED);</div><div class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.isExpired(e, now)) &#123;</div><div class="line">                <span class="comment">// This is a duplicate check, as preWriteCleanup already purged expired</span></div><div class="line">                <span class="comment">// entries, but let's accomodate an incorrect expiration queue.</span></div><div class="line">                enqueueNotification(entryKey, hash, valueReference, RemovalCause.EXPIRED);</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                recordLockedRead(e, now);</div><div class="line">                statsCounter.recordHits(<span class="number">1</span>);</div><div class="line">                <span class="comment">// we were concurrent with loading; don't consider refresh</span></div><div class="line">                <span class="keyword">return</span> value;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// immediately reuse invalid entries</span></div><div class="line">              writeQueue.remove(e);</div><div class="line">              accessQueue.remove(e);</div><div class="line">              <span class="keyword">this</span>.count = newCount; <span class="comment">// write-volatile</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//新建的元素，先做一些初始化的动作</span></div><div class="line">        <span class="keyword">if</span> (createNewEntry) &#123;</div><div class="line">          loadingValueReference = <span class="keyword">new</span> LoadingValueReference&lt;K, V&gt;();</div><div class="line"></div><div class="line">          <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">            e = newEntry(key, hash, first);</div><div class="line">            e.setValueReference(loadingValueReference);</div><div class="line">            table.set(index, e);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            e.setValueReference(loadingValueReference);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        unlock();</div><div class="line">        postWriteCleanup();</div><div class="line">      &#125;</div><div class="line"></div><div class="line"><span class="comment">//新建的元素，同步去远端load值</span></div><div class="line">      <span class="keyword">if</span> (createNewEntry) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">// Synchronizes on the entry to allow failing fast when a recursive load is</span></div><div class="line">          <span class="comment">// detected. This may be circumvented when an entry is copied, but will fail fast most</span></div><div class="line">          <span class="comment">// of the time.</span></div><div class="line">          <span class="keyword">synchronized</span> (e) &#123;</div><div class="line">            <span class="keyword">return</span> loadSync(key, hash, loadingValueReference, loader);</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          statsCounter.recordMisses(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// The entry already exists. Wait for loading.</span></div><div class="line">        <span class="comment">//否则阻塞等待别的线程load</span></div><div class="line">        <span class="keyword">return</span> waitForLoadingValue(e, key, valueReference);</div><div class="line">      &#125;</div><div class="line">    &#125; </div></pre></td></tr></table></figure></p>
<p>get中的waitForLoadingValue:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">waitForLoadingValue</span><span class="params">(ReferenceEntry&lt;K, V&gt; e, K key, ValueReference&lt;K, V&gt; valueReference)</span></span></div><div class="line">       <span class="keyword">throws</span> ExecutionException &#123;</div><div class="line">     <span class="keyword">if</span> (!valueReference.isLoading()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     checkState(!Thread.holdsLock(e), <span class="string">"Recursive load of: %s"</span>, key);</div><div class="line">     <span class="comment">// don't consider expiration as we're concurrent with loading</span></div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//getUninterruptibly同步获取</span></div><div class="line">       V value = valueReference.waitForValue();</div><div class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> InvalidCacheLoadException(<span class="string">"CacheLoader returned null for key "</span> + key + <span class="string">"."</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// re-read ticker now that loading has completed</span></div><div class="line">       <span class="keyword">long</span> now = map.ticker.read();</div><div class="line">       recordRead(e, now);</div><div class="line">       <span class="keyword">return</span> value;</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       statsCounter.recordMisses(<span class="number">1</span>);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div></pre></td></tr></table></figure><br>这里需要注意，如果在guava cache中，去远端load回结果为null，这时不会返回null，而是直接抛异常InvalidCacheLoadException出来。在db操作中，load结果为null是很常见的，所以一定要注意处理这点。</p>
<p>目前的解决办法是，拿到db返回结果时先判断下是否为null，如果为null则返回一个空对象出去。外边函数拿到get的结果后先取这个对象的一个属性，比如一个DO的id，判断是否为null，如果为null则返回null，否则返回对象本身。</p>
<h2 id="思考和总结"><a href="#思考和总结" class="headerlink" title="思考和总结"></a>思考和总结</h2><p>从代码中可以看出，Guava Cache不管是哪种过期策略，都是触发式的：即每一次的过期和reload动作都依赖外部的请求。所谓的refresh并不是自己起了一个线程去不停的reload。在getLiveValue方法中判断过期元素也不包括refresh策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(ReferenceEntry&lt;K, V&gt; entry, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">   checkNotNull(entry);</div><div class="line">   <span class="keyword">if</span> (expiresAfterAccess()</div><div class="line">       &amp;&amp; (now - entry.getAccessTime() &gt;= expireAfterAccessNanos)) &#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (expiresAfterWrite()</div><div class="line">       &amp;&amp; (now - entry.getWriteTime() &gt;= expireAfterWriteNanos)) &#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>这样的话，如果用了refreshAfterWrite，在load完一个值之后，过了很久同时来了一拨并发请求，那么大量请求都会拿到旧的值，可能会导致业务上的问题。不过这种场景也是有点略奇葩，不太常见。所以在使用各个特性时一定要结合自己的业务，如果不确定最好先写个小的demo试一下。最后再提一下，expireAfterWrite和refreshAfterWrite是可以一起使用的，官方文档中也有说明:<br><blockquote><p>In contrast to expireAfterWrite, refreshAfterWrite will make a key eligible for refresh after the specified duration, but a refresh will only be actually initiated when the entry is queried. (If CacheLoader.reload is implemented to be asynchronous, then the query will not be slowed down by the refresh.) So, for example, you can specify both refreshAfterWrite and expireAfterWrite on the same cache, so that the expiration timer on an entry isn’t blindly reset whenever an entry becomes eligible for a refresh, so if an entry isn’t queried after it comes eligible for refreshing, it is allowed to expire.</p>
</blockquote></p>
<p>Guava Cache的设计是很好的，但是感觉实现上不够“优雅”，代码读起来有点难受，整个学习过程是猜测-&gt;验证-&gt;明白。如果有问题欢迎讨论交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Guava-Cache简介&quot;&gt;&lt;a href=&quot;#Guava-Cache简介&quot; class=&quot;headerlink&quot; title=&quot;Guava Cache简介&quot;&gt;&lt;/a&gt;Guava Cache简介&lt;/h2&gt;&lt;p&gt;Local Cache是比较常用的后端开发“组件”，Guava中的Cache是一个很实用的Local Cache的实现，它支持下列特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;automatic loading of entries into the cache&lt;/li&gt;
&lt;li&gt;least-recently-used eviction when a maximum size is exceeded&lt;/li&gt;
&lt;li&gt;time-based expiration of entries, measured since last access or last write&lt;/li&gt;
&lt;li&gt;keys automatically wrapped in weak references&lt;/li&gt;
&lt;li&gt;values automatically wrapped in weak or soft references&lt;/li&gt;
&lt;li&gt;notification of evicted (or otherwise removed) entries&lt;/li&gt;
&lt;li&gt;accumulation of cache access statistics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些特性都是可选的，可在初始化时的建造者模式中进行配置。&lt;br&gt;今天主要根据源码来讲一下Guava Cache（19.0）的实现，具体的应用方法可以参考&lt;a href=&quot;https://github.com/google/guava/wiki/CachesExplained&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="后台" scheme="https://majiaji.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="Guava" scheme="https://majiaji.github.io/tags/Guava/"/>
    
      <category term="后台" scheme="https://majiaji.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Guava BloomFilter</title>
    <link href="https://majiaji.github.io/2016/12/04/Guava-BloomFilter/"/>
    <id>https://majiaji.github.io/2016/12/04/Guava-BloomFilter/</id>
    <published>2016-12-04T14:00:12.000Z</published>
    <updated>2016-12-04T17:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BloomFilter简介"><a href="#BloomFilter简介" class="headerlink" title="BloomFilter简介"></a>BloomFilter简介</h2><p>BloomFilter是一个可以快速判断一个元素是否在一个集合中的组件，它的设计也比较容易理解：构建的时候，一个元素经过几个hash函数hash后，命中一个bit数组的不同的位点，并把位点置为1。在判断的时候，也要执行同样的hash函数，只要有一个没有命中则这个元素一定不存在；否则有可能存在。只会有一种“误判”的情况：元素不在集合中，但被判断为在集合中。</p>
<p>因为构建时候多个元素经过hash可能命中同样的位点，这样会影响判断时候的准确率。可以想象一下，bit数组越大，hash函数散列效果越好，这样“冲突”的概率越小，判断的正确率越高。但是，扩大bit数组会占用更多内存，hash函数计算复杂度和数量会影响计算速度。所以如何平衡正确率与bit数组长度、hash函数的个数呢？有一个公式：</p>
<p>假设m是bit数组的bit的数量(长度)，k是hash函数的数量，n是在构造时元素的数量,p为判断时的错误率。则当它们满足下边两个公式时，有近似最优解。</p>
<blockquote><ol>
<li><p>m = -n * lnp / (ln2)^2 </p>
</li>
<li><p>k = m / n * ln2 </p>
</li>
</ol>
</blockquote>
<p>具体的推导过程可以看下<a href="https://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives" target="_blank" rel="external">这里。</a><br><a id="more"></a></p>
<h2 id="Guava中的实现"><a href="#Guava中的实现" class="headerlink" title="Guava中的实现"></a>Guava中的实现</h2><p>Guava中有一个BloomFilter的实现，下面来分析具体的实现方法：</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Guava的BloomFilter提供一个静态的创建方法，支持三个参数：</p>
<ol>
<li>Funnel&lt;? super T&gt;  转为PrimitiveSink的对象的类型，推荐使用enum。Funnels中支持一些基础类型，也可以自己实现。</li>
<li>expectedInsertions 预估的构造时元素的数量，即公式中的n。</li>
<li>fpp 错误率，即公式中的p，范围为0-1.0</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></div><div class="line">     Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy) &#123;</div><div class="line">   checkNotNull(funnel);</div><div class="line">   checkArgument(</div><div class="line">       expectedInsertions &gt;= <span class="number">0</span>, <span class="string">"Expected insertions (%s) must be &gt;= 0"</span>, expectedInsertions);</div><div class="line">   checkArgument(fpp &gt; <span class="number">0.0</span>, <span class="string">"False positive probability (%s) must be &gt; 0.0"</span>, fpp);</div><div class="line">   checkArgument(fpp &lt; <span class="number">1.0</span>, <span class="string">"False positive probability (%s) must be &lt; 1.0"</span>, fpp);</div><div class="line">   checkNotNull(strategy);</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (expectedInsertions == <span class="number">0</span>) &#123;</div><div class="line">     expectedInsertions = <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">//根据公式1. 计算bit数组的bit的数m</span></div><div class="line">   <span class="keyword">long</span> numBits = optimalNumOfBits(expectedInsertions, fpp);</div><div class="line">   <span class="comment">//根据公式2. 计算hash函数(执行hash次数)的数量k</span></div><div class="line">   <span class="keyword">int</span> numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">     <span class="comment">//生成bit数组，绑定hash策略（默认为MURMUR128_MITZ_64）</span></div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> BloomFilter&lt;T&gt;(<span class="keyword">new</span> BitArray(numBits), numHashFunctions, funnel, strategy);</div><div class="line">   &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Could not create BloomFilter of "</span> + numBits + <span class="string">" bits"</span>, e);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>调用BloomFilter实例的put方法来添加元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(</span></span></div><div class="line">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits) &#123;</div><div class="line">  <span class="keyword">long</span> bitSize = bits.bitSize();</div><div class="line">  <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</div><div class="line">  <span class="keyword">long</span> hash1 = lowerEight(bytes);</div><div class="line">  <span class="keyword">long</span> hash2 = upperEight(bytes);</div><div class="line"></div><div class="line">  <span class="keyword">boolean</span> bitsChanged = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">long</span> combinedHash = hash1;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; i++) &#123;</div><div class="line">    <span class="comment">// Make the combined hash positive and indexable</span></div><div class="line">    <span class="comment">//这里先和Long最大值与去掉符号位，模bit数组长度来定位，然后尝试将这位置1。最后加上Hashing.murmur3_128()结果的高8位后循环执行刚才过程。</span></div><div class="line">    bitsChanged |= bits.set((combinedHash &amp; Long.MAX_VALUE) % bitSize);</div><div class="line">    combinedHash += hash2;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//判断bit数组是否发生了变化，在上边循环中有一位被置为1则说明有变化，添加元素成功，返回true；否则可能之前已经添加过，或者和别的元素hash结果冲突，返回false;</span></div><div class="line">  <span class="keyword">return</span> bitsChanged;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>可见Guava中BloomFilter的实现并不是真正用了多种hash函数，而是通过加法和取模实现再hash。</p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>判断过程和添加过程类似，当有一个应该为1的位为0，则这个元素肯定不在集合中，直接返回false。因为有一定误判率p，所以函数名为mightContain：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(</span></span></div><div class="line">        T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits) &#123;</div><div class="line">      <span class="keyword">long</span> bitSize = bits.bitSize();</div><div class="line">      <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</div><div class="line">      <span class="keyword">long</span> hash1 = lowerEight(bytes);</div><div class="line">      <span class="keyword">long</span> hash2 = upperEight(bytes);</div><div class="line"></div><div class="line">      <span class="keyword">long</span> combinedHash = hash1;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; i++) &#123;</div><div class="line">        <span class="comment">// Make the combined hash positive and indexable</span></div><div class="line">        <span class="keyword">if</span> (!bits.get((combinedHash &amp; Long.MAX_VALUE) % bitSize)) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        combinedHash += hash2;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<h2 id="在工程中的应用"><a href="#在工程中的应用" class="headerlink" title="在工程中的应用"></a>在工程中的应用</h2><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>BloomFilter常用在爬虫系统中的url去重，可以节省大量内存空间。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>BloomFilter可以挡在系统的最前边，进行流量有效性的判断和过滤。如果判断不是此系统的业务则直接丢弃，减轻服务压力。理想情况下，流量经过的组件的顺序是这样的:BloomFilter-&gt;本地缓存-&gt;远端缓存-&gt;db，中间每个环节都可以命中并返回，减轻对后边的压力。</p>
<h3 id="关键词过滤"><a href="#关键词过滤" class="headerlink" title="关键词过滤"></a>关键词过滤</h3><p>BloomFilter可以支持keyword filter。英文文章有自然的空格字符分词，所以可以直接将敏感词库建立BloomFilter，对文章进行过滤。但是中文就有点尴尬了，只能使用多模式匹配(AC自动机、 Wu-Manber等)的精确算法来进行过滤了。</p>
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>对于分布式系统来说，每台机器上都会有自己的BloomFilter。每个BloomFilter都有自己的版本号，它们需要定时去一个统一的数据源(db或者文件)中load数据，并拿远端的版本号和自己本地版本号进行对比:如果相同则直接跳过，如果不同则需要拿远端数据进行增量构建；同时还需要定时在系统负载低时进行全量构建，保障所有机器上BloomFilter的有效性和正确性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BloomFilter简介&quot;&gt;&lt;a href=&quot;#BloomFilter简介&quot; class=&quot;headerlink&quot; title=&quot;BloomFilter简介&quot;&gt;&lt;/a&gt;BloomFilter简介&lt;/h2&gt;&lt;p&gt;BloomFilter是一个可以快速判断一个元素是否在一个集合中的组件，它的设计也比较容易理解：构建的时候，一个元素经过几个hash函数hash后，命中一个bit数组的不同的位点，并把位点置为1。在判断的时候，也要执行同样的hash函数，只要有一个没有命中则这个元素一定不存在；否则有可能存在。只会有一种“误判”的情况：元素不在集合中，但被判断为在集合中。&lt;/p&gt;
&lt;p&gt;因为构建时候多个元素经过hash可能命中同样的位点，这样会影响判断时候的准确率。可以想象一下，bit数组越大，hash函数散列效果越好，这样“冲突”的概率越小，判断的正确率越高。但是，扩大bit数组会占用更多内存，hash函数计算复杂度和数量会影响计算速度。所以如何平衡正确率与bit数组长度、hash函数的个数呢？有一个公式：&lt;/p&gt;
&lt;p&gt;假设m是bit数组的bit的数量(长度)，k是hash函数的数量，n是在构造时元素的数量,p为判断时的错误率。则当它们满足下边两个公式时，有近似最优解。&lt;/p&gt;
&lt;blockquote&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;m = -n * lnp / (ln2)^2 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;k = m / n * ln2 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体的推导过程可以看下&lt;a href=&quot;https://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives&quot;&gt;这里。&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="后台" scheme="https://majiaji.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="Guava" scheme="https://majiaji.github.io/tags/Guava/"/>
    
      <category term="后台" scheme="https://majiaji.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>httpClient参数设置</title>
    <link href="https://majiaji.github.io/2016/12/03/httpClient%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/"/>
    <id>https://majiaji.github.io/2016/12/03/httpClient参数设置/</id>
    <published>2016-12-02T17:27:28.000Z</published>
    <updated>2016-12-04T06:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>httpClient是一个不考虑向下兼容的库，从3.x到4.x,几乎每个版本都有较大差异。本文使用的是4.5.2。</p>
<p>httpClient是一个比较常用的库，客户端使用它，或者以它为底层的网络库来向服务端发http请求。通常为了简单，每次需要请求的时候都会new一个HttpClient实例出来，拿到结果后再close掉这个实例。</p>
<p>但是对于服务端来说，在高并发的时候，每次new实例出来，在性能上是不可接受的。所以考虑所有的请求只用一个httpClient实例来搞定，这时候就需要好好check下这个httpClient的参数。</p>
<a id="more"></a>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> HttpClient httpClient;</div><div class="line"></div><div class="line">   <span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//连接池配置</span></div><div class="line">        PoolingHttpClientConnectionManager connectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager();</div><div class="line">        <span class="comment">//最大并发连接数</span></div><div class="line">        connectionManager.setMaxTotal(<span class="number">500</span>);</div><div class="line">        <span class="comment">//每个url支持的并发连接数</span></div><div class="line">        connectionManager.setDefaultMaxPerRoute(<span class="number">200</span>);</div><div class="line">        <span class="comment">//超时配置</span></div><div class="line">        RequestConfig requestConfig = RequestConfig.custom()</div><div class="line">                <span class="comment">//从连接池中取连接</span></div><div class="line">                .setConnectionRequestTimeout(<span class="number">1000</span>)</div><div class="line">                <span class="comment">//进行连接</span></div><div class="line">                .setConnectTimeout(<span class="number">5000</span>)</div><div class="line">                <span class="comment">//socket读</span></div><div class="line">                .setSocketTimeout(<span class="number">5000</span>).build();</div><div class="line">        httpClient = HttpClients.custom()</div><div class="line">                .setDefaultRequestConfig(requestConfig)</div><div class="line">                .setConnectionManager(connectionManager)</div><div class="line">                .build();</div><div class="line">    &#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>默认情况下，Per default this implementation will create no more than than 2 concurrent connections per given route and no more 20 connections in total。所以需要设置下总的连接数和每个route支持的连接数，否则当并发量大时，从连接池中取连接时会取不到，导致请求失败。</p>
<p>使用httpClient最怕发生阻塞且没有超时返回的情况，所以需要根据自己的需求配置三个超时时间。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;httpClient是一个不考虑向下兼容的库，从3.x到4.x,几乎每个版本都有较大差异。本文使用的是4.5.2。&lt;/p&gt;
&lt;p&gt;httpClient是一个比较常用的库，客户端使用它，或者以它为底层的网络库来向服务端发http请求。通常为了简单，每次需要请求的时候都会new一个HttpClient实例出来，拿到结果后再close掉这个实例。&lt;/p&gt;
&lt;p&gt;但是对于服务端来说，在高并发的时候，每次new实例出来，在性能上是不可接受的。所以考虑所有的请求只用一个httpClient实例来搞定，这时候就需要好好check下这个httpClient的参数。&lt;/p&gt;
    
    </summary>
    
      <category term="后台" scheme="https://majiaji.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
      <category term="后台" scheme="https://majiaji.github.io/tags/%E5%90%8E%E5%8F%B0/"/>
    
      <category term="httpClient" scheme="https://majiaji.github.io/tags/httpClient/"/>
    
  </entry>
  
  <entry>
    <title>前端开发的浮光掠影</title>
    <link href="https://majiaji.github.io/2016/11/23/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E6%B5%AE%E5%85%89%E6%8E%A0%E5%BD%B1/"/>
    <id>https://majiaji.github.io/2016/11/23/前端开发的浮光掠影/</id>
    <published>2016-11-22T16:04:18.000Z</published>
    <updated>2016-11-26T11:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间有个比较🔥的文章 <a href="https://zhuanlan.zhihu.com/p/22782487" target="_blank" rel="external">在2016年学JavaScript是一种什么样的体验</a> 读完之后深深感受到了前端同学的痛点：用好各种框架、脚手架已经让人应接不暇了，与此同时还要不停地造自己的小轮子，着实不易。</p>
<p>在大学的有段时间，我也考虑过去做前端。因为所见即所得的东西还是很容易给人成就感的。后来只坚持学了半个学期就放弃了，主要因为一直没有搞懂，也记不住各种css标签的含义，这样导致每次在调样式的时候都无比捉急，连最基础的还原视觉稿都做不到。于是又悻悻的回到了黑框框的后端世界。</p>
<p>正式工作后也有机会接触一些前端的工作，在工作之余我总结了自己常用的开发模式和套路，分享给大家：</p>
<a id="more"></a>
<h2 id="Velocity-jQuery-Bootstrap"><a href="#Velocity-jQuery-Bootstrap" class="headerlink" title="Velocity + jQuery + Bootstrap"></a>Velocity + jQuery + Bootstrap</h2><p>这个用的是最多的。Velocity结合springMVC一起使用，在Controller前，把对象塞到一个modelMap中，然后由VelocityEngine根据vm模板去渲染，然后再返回给浏览器。之后前端页面的业务逻辑通过ajax请求后端接口，然后用jQuery直接操作dom节点修改，简单粗暴。</p>
<p>这个套路是比较简单也比较常用的，但是有一个问题，如果从0开始搭建一个系统的前端框架那么要怎么做才好呢？header啊sidebar啊布局啊还是不知道如何下手。这时候可以用下 <a href="http://www.bootcss.com/p/layoutit" target="_blank" rel="external">Bootstrap可视化布局系统</a> 可以用这个工具直接拖出来想要的前端栅格布局、导航栏、边栏二级导航（如果需要)、footer等，不满意的细节可以把它down下来自己手动修改一下，需要的组件可以到 <a href="http://www.bootcss.com/" target="_blank" rel="external">Bootstrap组件库</a>中查找。</p>
<p>Bootstrap库中的组件还是比较齐全的，而且因为使用的人很多也比较稳定，不会有什么奇怪的bug。如果不仅仅满足于这些基础的组件，还可以到<a href="http://www.jq22.com/" target="_blank" rel="external">jQuery插件库</a>中查找自己喜欢的酷炫的jQuery组件。不过这时候需要注意组件库之间有可能会冲突，引用时候要check一下。</p>
<p>总结：<br>用上述工具可以快速从零搭建起来一个前端系统框架，并进行业务开发。需要了解一下Velocity和jQuery的语法，尤其要熟练使用jQuery选择器。<br>优点：<br>符合简单的“面向过程”的开发思维，容易上手，可以快速实现需求。<br>缺点：<br>当需要动态操作大量的dom节点时候简直就是灾难：当有业务需要由ajax返回的结果决定展示什么内容时，就需要用jQuery直接操作很多dom节点。这时候就比较考眼力了，需要在各种尖括号的标签之间看清楚字符串引号是单引号还是双引号…… 而且团队中的同学也很难看明白这一坨dom标签是想干嘛，难以维护。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a href="https://vuejs.org.cn/guide/" target="_blank" rel="external">Vue</a></h2><p>Vue是在下午吃水果时听到同事提起的，回来学习了一下后发现真的是个好东西：Vue支持响应式的数据双向绑定。在使用jQuery手工操作dom时，我们的代码常常是命令式的、重复的和易错的。Vue拥抱数据驱动视图的概念，我们可以把要操作的对象声明为一个Vue对象，同时在dom标签中用特殊的占位符（双大括号）在占位，这样就进行了绑定。每次修改Vue对象，dom中的元素会响应式的更新，同样也可以实时的拿到Vue对象中的值和服务端进行交互，再也不用熟记各种花式的jQuery选择器技巧了。</p>
<p>总结：<br>Vue对于熟练Velocity的同学非常容易上手，它们都是使用了自己的标签进行占位。Vue只关注视图层，可以非常容易和jQuery、Bootstrap等其他框架共同使用。<br>优点：<br>双向绑定，与其他框架友好兼容，上手简单。<br>缺点：暂无。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a></h2><p>React是现在最🔥的前端框架。首先要转变下思维：忘掉Velocity和Vue的模板+占位符的开发方式，使用React时要把web页面中的每一部分抽象成一个“组件”，每个组件都要抽出来一个函数单独实现渲染逻辑。最后再把这些渲染逻辑像搭积木一样堆起来，再去整体进行render。</p>
<p>React中有一个非常重要的概念：状态中心，在我看来它就像是一个对外统一的接口，在渲染函数中可以用this.state取到各个属性的值，当使用this.setState修改属性值时，会进行dom diff，然后React自动调用render方法，再次渲染所有组件。</p>
<p>使用React需要了解组件的生命周期的状态和对应的处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillMount()</div><div class="line">componentDidMount()</div><div class="line">componentWillUpdate(object nextProps, object nextState)</div><div class="line">componentDidUpdate(object prevProps, object prevState)</div><div class="line">componentWillUnmount()</div></pre></td></tr></table></figure>
<p>其中通过Ajax获取服务端数据，进行初始化state的方法要放在componentDidMount()中执行。考虑性能优化时需要实现另外的状态处理函数shouldComponentUpdate()。搭建复杂的页面需要学习redux。</p>
<p>使用React可能是因为业务方觉得厂内的对React封装的那一套组件更好看一些，而且厂内的前端同学也在大力推广他们的新组件库，并且提供技术支持。但是对于后端同学来说，React似乎不是那么“友好”，需要学习理解和排坑的成本略高。遇到问题时可查询的资料不多。React不能直接简单操作dom(有麻烦的办法)，当想操作dom实现一个简单逻辑时比较困难。</p>
<p>总结：<br>React适合那种dom类型和位置都确定的复杂页面，它支持数据的单向绑定，即修改state中的属性，然后自动的进行render。对于简单的页面来说，考虑到上手难度，有点得不偿失。但是这是未来的趋势嘛，学习一下还是很有必要的。<br>优点：<br>组件化、函数式、社区活跃<br>缺点：<br>学习成本高，上手难度大，排查问题困难</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文没有讨论各种前端框架底层的实现，如Vue的底层实现和React的Virtual DOM哪个性能更好，仅仅是站在一个纯初级使用者的角度去谈谈自己在使用这些框架时的感受和理解。所以只能算是浮光掠影了。<br>如有理解错误的地方，欢迎讨论交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间有个比较🔥的文章 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/22782487&quot;&gt;在2016年学JavaScript是一种什么样的体验&lt;/a&gt; 读完之后深深感受到了前端同学的痛点：用好各种框架、脚手架已经让人应接不暇了，与此同时还要不停地造自己的小轮子，着实不易。&lt;/p&gt;
&lt;p&gt;在大学的有段时间，我也考虑过去做前端。因为所见即所得的东西还是很容易给人成就感的。后来只坚持学了半个学期就放弃了，主要因为一直没有搞懂，也记不住各种css标签的含义，这样导致每次在调样式的时候都无比捉急，连最基础的还原视觉稿都做不到。于是又悻悻的回到了黑框框的后端世界。&lt;/p&gt;
&lt;p&gt;正式工作后也有机会接触一些前端的工作，在工作之余我总结了自己常用的开发模式和套路，分享给大家：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://majiaji.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://majiaji.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://majiaji.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>啊，第一篇博客</title>
    <link href="https://majiaji.github.io/2016/11/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://majiaji.github.io/2016/11/21/第一篇博客/</id>
    <published>2016-11-21T07:06:25.000Z</published>
    <updated>2016-11-21T16:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2>为什么要写博客</h2>

<p>现在技术越来越好了，网络内容的主流媒介完成了文字-&gt;图片-&gt;视频-&gt;直播这样的转变。下班回来后，经常各种app(微信知乎头条微博等)刷一遍，来补充一下白天被抽空的精神世界。后来我发现了一个问题，对于各种网络内容来说，我一直都是一个“看客”，几乎很少去评论或者主动提出一些观点，这是一件非常可怕的事情。虽然看别人的东西也能学到很多东西，但是少了一个自己主动思考的过程。最近也在追<a href="http://www.hbo.com/westworld" target="_blank" rel="external">西部世界</a>，这算不算一种自我觉醒呢？哈哈。<br>所以打算从今天开始写博客了，可能包括自己日常生活中的感悟、吐槽和理解，还会分享一些技术知识和踩过的坑，希望能帮助到大家，也希望能认识更多的朋友。</p>
<p></p><h2>flag</h2><br>这里先立个flag，每周至少一篇详细的技术博客，坚持，共勉。<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;为什么要写博客&lt;/h2&gt;

&lt;p&gt;现在技术越来越好了，网络内容的主流媒介完成了文字-&amp;gt;图片-&amp;gt;视频-&amp;gt;直播这样的转变。下班回来后，经常各种app(微信知乎头条微博等)刷一遍，来补充一下白天被抽空的精神世界。后来我发现了一个问题，对于各种网络内容来说，我一
    
    </summary>
    
      <category term="闲谈" scheme="https://majiaji.github.io/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="闲谈" scheme="https://majiaji.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
</feed>
